#!/usr/bin/perl
use strict;
use warnings;
# Try to use the best available YAML module
BEGIN {
    eval { require YAML::XS; YAML::XS->import(qw(LoadFile DumpFile)); 1; } ||
    eval { require YAML; YAML->import(qw(LoadFile DumpFile)); 1; } ||
    eval { require YAML::Tiny; YAML::Tiny->import(); 1; } ||
    die "No YAML module found! Please install one: cpan YAML::XS or cpan YAML or cpan YAML::Tiny\n";
}
use File::Temp qw(tempfile);
use Getopt::Long;

# SQL Formatter for Extracted YAML - Uses pg_format to beautify SQL
# Processes YAML files generated by sql_variable_extractor_multi.pl

my $input_file = '';
my $output_file = '';
my $help = 0;
my $pg_format_path = 'pg_format';  # Default assumes pg_format is in PATH

GetOptions(
    'input|i=s'     => \$input_file,
    'output|o=s'    => \$output_file,
    'pg-format=s'   => \$pg_format_path,
    'help|h'        => \$help,
) or show_usage();

show_usage() if $help;

# Default input file
$input_file = 'extracted_sql.yaml' unless $input_file;

# Generate default output filename
unless ($output_file) {
    $output_file = $input_file;
    $output_file =~ s/\.yaml$/_formatted.yaml/;
    $output_file .= '_formatted.yaml' unless $output_file =~ /_formatted\.yaml$/;
}

# Check if input file exists
die "Error: Input YAML file '$input_file' not found!\n" unless -f $input_file;

# Check if pg_format is available
my $use_pg_format = command_exists($pg_format_path);
unless ($use_pg_format) {
    print "Warning: pg_format not found! Using built-in SQL formatter instead.\n";
    print "For better formatting, install pg_format: cpan SQL::Beautify or apt-get install pgformatter\n\n";
}

print "SQL YAML Formatter v1.0\n";
print "========================\n";
print "Input file:  $input_file\n";
print "Output file: $output_file\n";
print "pg_format:   $pg_format_path\n\n";

# Load the YAML file with fallback handling
my $data;
eval {
    if (defined &LoadFile) {
        $data = LoadFile($input_file);
    } elsif (defined &YAML::Tiny::LoadFile) {
        $data = YAML::Tiny::LoadFile($input_file);
    } else {
        die "No suitable YAML loader found\n";
    }
};
if ($@) {
    die "Error loading YAML file '$input_file': $@\n";
}

# Verify this is a valid extracted SQL YAML file
unless (exists $data->{sql_assignments} && exists $data->{metadata}) {
    die "Error: '$input_file' doesn't appear to be a valid extracted SQL YAML file!\n";
}

my $formatted_count = 0;
my $error_count = 0;
my $total_assignments = scalar keys %{$data->{sql_assignments}};

print "Processing $total_assignments SQL assignments...\n\n";

# Process each SQL assignment
foreach my $assignment_key (sort keys %{$data->{sql_assignments}}) {
    my $assignment = $data->{sql_assignments}->{$assignment_key};
    my $original_sql = $assignment->{sql};

    print "Formatting: $assignment->{variable_name} (line $assignment->{line_number})... ";

    # Format the SQL using pg_format or built-in formatter
    my $formatted_sql = $use_pg_format ?
        format_sql_with_pg_format($original_sql) :
        format_sql_builtin($original_sql);

    if ($formatted_sql) {
        $assignment->{sql} = $formatted_sql;
        $assignment->{formatted_with} = $use_pg_format ? 'pg_format' : 'builtin';
        $assignment->{formatted_at} = scalar localtime();
        $formatted_count++;
        print "OK\n";
    } else {
        print "FAILED (keeping original)\n";
        $error_count++;
    }
}

# Update metadata
$data->{metadata}->{formatted_at} = scalar localtime();
$data->{metadata}->{formatted_with} = $use_pg_format ? 'pg_format' : 'builtin';
$data->{metadata}->{formatting_stats} = {
    total_assignments => $total_assignments,
    successfully_formatted => $formatted_count,
    formatting_errors => $error_count,
};

# Save the updated YAML file with fallback handling
eval {
    if (defined &DumpFile) {
        DumpFile($output_file, $data);
    } elsif (defined &YAML::Tiny::DumpFile) {
        YAML::Tiny::DumpFile($output_file, $data);
    } else {
        die "No suitable YAML dumper found\n";
    }
};
if ($@) {
    die "Error saving formatted YAML file '$output_file': $@\n";
}

print "\nFormatting Complete!\n";
print "===================\n";
print "Successfully formatted: $formatted_count/$total_assignments SQL statements\n";
print "Formatting errors: $error_count\n";
print "Output saved to: $output_file\n";

exit 0;

# Subroutines
sub format_sql_with_pg_format {
    my $sql = shift;

    # Clean up the SQL - remove any formatting artifacts
    $sql =~ s/^\s+|\s+$//g;  # Trim whitespace
    $sql =~ s/\n\s*\n/\n/g;  # Remove empty lines

    # Create temporary file for SQL input
    my ($temp_fh, $temp_file) = tempfile(SUFFIX => '.sql', UNLINK => 1);
    print $temp_fh $sql;
    close $temp_fh;

    # Run pg_format
    my $formatted_sql = '';
    my $cmd = "$pg_format_path --keyword-case=2 --function-case=2 --no-extra-line --wrap-limit=80 '$temp_file' 2>/dev/null";

    eval {
        $formatted_sql = `$cmd`;
        chomp $formatted_sql if $formatted_sql;
    };

    # Check if formatting was successful
    if ($? == 0 && $formatted_sql && length($formatted_sql) > 0) {
        # Clean up the formatted SQL
        $formatted_sql =~ s/^\s+|\s+$//g;
        return $formatted_sql;
    }

    return undef;  # Return undef on error
}

sub format_sql_builtin {
    my $sql = shift;

    # Clean up the SQL
    $sql =~ s/^\s+|\s+$//g;  # Trim whitespace
    $sql =~ s/\s+/ /g;       # Normalize whitespace

    # Convert to uppercase for keywords
    $sql =~ s/\b(select|from|where|and|or|order|by|group|having|limit|offset|insert|into|values|update|set|delete|create|table|alter|drop|index|join|inner|left|right|outer|full|on|as|distinct|union|all|case|when|then|else|end|count|sum|avg|max|min|exists|not|null|is|like|in|between|desc|asc)\b/uc($1)/gei;

    # Format major clauses on new lines
    $sql =~ s/\b(SELECT|FROM|WHERE|ORDER BY|GROUP BY|HAVING|LIMIT|OFFSET|INSERT INTO|VALUES|UPDATE|SET|DELETE FROM|CREATE TABLE|ALTER TABLE|DROP TABLE|DROP INDEX)\b/\n$1/gi;

    # Format JOINs
    $sql =~ s/\b((?:INNER|LEFT|RIGHT|OUTER|FULL)\s+JOIN|JOIN)\b/\n  $1/gi;
    $sql =~ s/\bON\b/\n    ON/gi;

    # Format logical operators in WHERE clauses
    $sql =~ s/\b(AND|OR)\b(?=\s+\w)/\n  $1/gi;

    # Format INSERT VALUES
    $sql =~ s/VALUES\s*\(/VALUES\n  (/gi;

    # Format SET clauses
    $sql =~ s/,\s*(?=\w+\s*=)/,\n     /g;

    # Clean up extra newlines and indentation
    $sql =~ s/^\n+//;        # Remove leading newlines
    $sql =~ s/\n\s*\n/\n/g;  # Remove empty lines
    $sql =~ s/\n\s*$/\n/;    # Clean trailing whitespace

    return $sql;
}

sub command_exists {
    my $cmd = shift;
    my $devnull = $^O eq 'MSWin32' ? 'NUL' : '/dev/null';
    return system("$cmd --version > $devnull 2>&1") == 0;
}

sub show_usage {
    print <<'EOF';
SQL YAML Formatter v1.0 - Format SQL in extracted YAML using pg_format

SYNOPSIS:
    format_extracted_sql.pl [options]

OPTIONS:
    -i, --input <file>      Input YAML file (default: extracted_sql.yaml)
    -o, --output <file>     Output YAML file (default: input_formatted.yaml)
    --pg-format <path>      Path to pg_format executable (default: pg_format)
    -h, --help              Show this help message

DESCRIPTION:
    This script reads YAML files generated by sql_variable_extractor_multi.pl
    and formats all SQL statements using pg_format, creating a new YAML file
    with beautifully formatted SQL.

REQUIREMENTS:
    - One of: YAML::XS, YAML, or YAML::Tiny modules (cpan YAML::XS or cpan YAML)
    - pg_format tool (cpan SQL::Beautify or apt-get install pgformatter) - optional

EXAMPLES:
    # Format default extracted_sql.yaml file
    perl format_extracted_sql.pl

    # Specify input and output files
    perl format_extracted_sql.pl -i my_queries.yaml -o formatted_queries.yaml

    # Use specific pg_format path
    perl format_extracted_sql.pl --pg-format /usr/local/bin/pg_format

NOTES:
    - Original SQL is replaced with formatted version
    - Metadata is added to track formatting information
    - If formatting fails for any SQL, original is preserved
    - pg_format options used: --keyword-case=2 --function-case=2 --no-extra-line --wrap-limit=80
    - Falls back to built-in formatter if pg_format is not available

EOF
    exit 0;
}
